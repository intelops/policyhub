// Code generated by cue get go. DO NOT EDIT.

//cue:generate cue get go k8s.io/api/resource/v1alpha2

package v1alpha2

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/api/core/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/types"
)

// Finalizer is the finalizer that gets set for claims
// which were allocated through a builtin controller.
#Finalizer: "dra.k8s.io/delete-protection"

// ResourceClaim describes which resources are needed by a resource consumer.
// Its status tracks whether the resource has been allocated and what the
// resulting attributes are.
//
// This is an alpha type and requires enabling the DynamicResourceAllocation
// feature gate.
#ResourceClaim: {
	metav1.#TypeMeta

	// Standard object metadata
	// +optional
	metadata?: metav1.#ObjectMeta @go(ObjectMeta) @protobuf(1,bytes,opt)

	// Spec describes the desired attributes of a resource that then needs
	// to be allocated. It can only be set once when creating the
	// ResourceClaim.
	spec: #ResourceClaimSpec @go(Spec) @protobuf(2,bytes)

	// Status describes whether the resource is available and with which
	// attributes.
	// +optional
	status?: #ResourceClaimStatus @go(Status) @protobuf(3,bytes,opt)
}

// ResourceClaimSpec defines how a resource is to be allocated.
#ResourceClaimSpec: {
	// ResourceClassName references the driver and additional parameters
	// via the name of a ResourceClass that was created as part of the
	// driver deployment.
	resourceClassName: string @go(ResourceClassName) @protobuf(1,bytes)

	// ParametersRef references a separate object with arbitrary parameters
	// that will be used by the driver when allocating a resource for the
	// claim.
	//
	// The object must be in the same namespace as the ResourceClaim.
	// +optional
	parametersRef?: null | #ResourceClaimParametersReference @go(ParametersRef,*ResourceClaimParametersReference) @protobuf(2,bytes,opt)

	// Allocation can start immediately or when a Pod wants to use the
	// resource. "WaitForFirstConsumer" is the default.
	// +optional
	allocationMode?: #AllocationMode @go(AllocationMode) @protobuf(3,bytes,opt)
}

// AllocationMode describes whether a ResourceClaim gets allocated immediately
// when it gets created (AllocationModeImmediate) or whether allocation is
// delayed until it is needed for a Pod
// (AllocationModeWaitForFirstConsumer). Other modes might get added in the
// future.
#AllocationMode: string // #enumAllocationMode

#enumAllocationMode:
	#AllocationModeWaitForFirstConsumer |
	#AllocationModeImmediate

// When a ResourceClaim has AllocationModeWaitForFirstConsumer, allocation is
// delayed until a Pod gets scheduled that needs the ResourceClaim. The
// scheduler will consider all resource requirements of that Pod and
// trigger allocation for a node that fits the Pod.
#AllocationModeWaitForFirstConsumer: #AllocationMode & "WaitForFirstConsumer"

// When a ResourceClaim has AllocationModeImmediate, allocation starts
// as soon as the ResourceClaim gets created. This is done without
// considering the needs of Pods that will use the ResourceClaim
// because those Pods are not known yet.
#AllocationModeImmediate: #AllocationMode & "Immediate"

// ResourceClaimStatus tracks whether the resource has been allocated and what
// the resulting attributes are.
#ResourceClaimStatus: {
	// DriverName is a copy of the driver name from the ResourceClass at
	// the time when allocation started.
	// +optional
	driverName?: string @go(DriverName) @protobuf(1,bytes,opt)

	// Allocation is set by the resource driver once a resource or set of
	// resources has been allocated successfully. If this is not specified, the
	// resources have not been allocated yet.
	// +optional
	allocation?: null | #AllocationResult @go(Allocation,*AllocationResult) @protobuf(2,bytes,opt)

	// ReservedFor indicates which entities are currently allowed to use
	// the claim. A Pod which references a ResourceClaim which is not
	// reserved for that Pod will not be started.
	//
	// There can be at most 32 such reservations. This may get increased in
	// the future, but not reduced.
	//
	// +listType=map
	// +listMapKey=uid
	// +patchStrategy=merge
	// +patchMergeKey=uid
	// +optional
	reservedFor?: [...#ResourceClaimConsumerReference] @go(ReservedFor,[]ResourceClaimConsumerReference) @protobuf(3,bytes,opt)

	// DeallocationRequested indicates that a ResourceClaim is to be
	// deallocated.
	//
	// The driver then must deallocate this claim and reset the field
	// together with clearing the Allocation field.
	//
	// While DeallocationRequested is set, no new consumers may be added to
	// ReservedFor.
	// +optional
	deallocationRequested?: bool @go(DeallocationRequested) @protobuf(4,varint,opt)
}

#ResourceClaimReservedForMaxSize: 32

// AllocationResult contains attributes of an allocated resource.
#AllocationResult: {
	// ResourceHandles contain the state associated with an allocation that
	// should be maintained throughout the lifetime of a claim. Each
	// ResourceHandle contains data that should be passed to a specific kubelet
	// plugin once it lands on a node. This data is returned by the driver
	// after a successful allocation and is opaque to Kubernetes. Driver
	// documentation may explain to users how to interpret this data if needed.
	//
	// Setting this field is optional. It has a maximum size of 32 entries.
	// If null (or empty), it is assumed this allocation will be processed by a
	// single kubelet plugin with no ResourceHandle data attached. The name of
	// the kubelet plugin invoked will match the DriverName set in the
	// ResourceClaimStatus this AllocationResult is embedded in.
	//
	// +listType=atomic
	// +optional
	resourceHandles?: [...#ResourceHandle] @go(ResourceHandles,[]ResourceHandle) @protobuf(1,bytes,opt)

	// This field will get set by the resource driver after it has allocated
	// the resource to inform the scheduler where it can schedule Pods using
	// the ResourceClaim.
	//
	// Setting this field is optional. If null, the resource is available
	// everywhere.
	// +optional
	availableOnNodes?: null | v1.#NodeSelector @go(AvailableOnNodes,*v1.NodeSelector) @protobuf(2,bytes,opt)

	// Shareable determines whether the resource supports more
	// than one consumer at a time.
	// +optional
	shareable?: bool @go(Shareable) @protobuf(3,varint,opt)
}

#AllocationResultResourceHandlesMaxSize: 32

// ResourceHandle holds opaque resource data for processing by a specific kubelet plugin.
#ResourceHandle: {
	// DriverName specifies the name of the resource driver whose kubelet
	// plugin should be invoked to process this ResourceHandle's data once it
	// lands on a node. This may differ from the DriverName set in
	// ResourceClaimStatus this ResourceHandle is embedded in.
	driverName?: string @go(DriverName) @protobuf(1,bytes,opt)

	// Data contains the opaque data associated with this ResourceHandle. It is
	// set by the controller component of the resource driver whose name
	// matches the DriverName set in the ResourceClaimStatus this
	// ResourceHandle is embedded in. It is set at allocation time and is
	// intended for processing by the kubelet plugin whose name matches
	// the DriverName set in this ResourceHandle.
	//
	// The maximum size of this field is 16KiB. This may get increased in the
	// future, but not reduced.
	// +optional
	data?: string @go(Data) @protobuf(2,bytes,opt)

	// If StructuredData is set, then it needs to be used instead of Data.
	//
	// +optional
	structuredData?: null | #StructuredResourceHandle @go(StructuredData,*StructuredResourceHandle) @protobuf(5,bytes,opt)
}

#ResourceHandleDataMaxSize: 16384

// StructuredResourceHandle is the in-tree representation of the allocation result.
#StructuredResourceHandle: {
	// VendorClassParameters are the per-claim configuration parameters
	// from the resource class at the time that the claim was allocated.
	//
	// +optional
	vendorClassParameters?: runtime.#RawExtension @go(VendorClassParameters) @protobuf(1,bytes,opt)

	// VendorClaimParameters are the per-claim configuration parameters
	// from the resource claim parameters at the time that the claim was
	// allocated.
	//
	// +optional
	vendorClaimParameters?: runtime.#RawExtension @go(VendorClaimParameters) @protobuf(2,bytes,opt)

	// NodeName is the name of the node providing the necessary resources
	// if the resources are local to a node.
	//
	// +optional
	nodeName?: string @go(NodeName) @protobuf(4,bytes)

	// Results lists all allocated driver resources.
	//
	// +listType=atomic
	results: [...#DriverAllocationResult] @go(Results,[]DriverAllocationResult) @protobuf(5,bytes)
}

// DriverAllocationResult contains vendor parameters and the allocation result for
// one request.
#DriverAllocationResult: {
	// VendorRequestParameters are the per-request configuration parameters
	// from the time that the claim was allocated.
	//
	// +optional
	vendorRequestParameters?: runtime.#RawExtension @go(VendorRequestParameters) @protobuf(1,bytes,opt)

	#AllocationResultModel
}

// AllocationResultModel must have one and only one field set.
#AllocationResultModel: {
	// NamedResources describes the allocation result when using the named resources model.
	//
	// +optional
	namedResources?: null | #NamedResourcesAllocationResult @go(NamedResources,*NamedResourcesAllocationResult) @protobuf(1,bytes,opt)
}

// ResourceClaimList is a collection of claims.
#ResourceClaimList: {
	metav1.#TypeMeta

	// Standard list metadata
	// +optional
	metadata?: metav1.#ListMeta @go(ListMeta) @protobuf(1,bytes,opt)

	// Items is the list of resource claims.
	items: [...#ResourceClaim] @go(Items,[]ResourceClaim) @protobuf(2,bytes,rep)
}

// PodSchedulingContext objects hold information that is needed to schedule
// a Pod with ResourceClaims that use "WaitForFirstConsumer" allocation
// mode.
//
// This is an alpha type and requires enabling the DynamicResourceAllocation
// feature gate.
#PodSchedulingContext: {
	metav1.#TypeMeta

	// Standard object metadata
	// +optional
	metadata?: metav1.#ObjectMeta @go(ObjectMeta) @protobuf(1,bytes,opt)

	// Spec describes where resources for the Pod are needed.
	spec: #PodSchedulingContextSpec @go(Spec) @protobuf(2,bytes)

	// Status describes where resources for the Pod can be allocated.
	// +optional
	status?: #PodSchedulingContextStatus @go(Status) @protobuf(3,bytes,opt)
}

// PodSchedulingContextSpec describes where resources for the Pod are needed.
#PodSchedulingContextSpec: {
	// SelectedNode is the node for which allocation of ResourceClaims that
	// are referenced by the Pod and that use "WaitForFirstConsumer"
	// allocation is to be attempted.
	// +optional
	selectedNode?: string @go(SelectedNode) @protobuf(1,bytes,opt)

	// PotentialNodes lists nodes where the Pod might be able to run.
	//
	// The size of this field is limited to 128. This is large enough for
	// many clusters. Larger clusters may need more attempts to find a node
	// that suits all pending resources. This may get increased in the
	// future, but not reduced.
	//
	// +listType=atomic
	// +optional
	potentialNodes?: [...string] @go(PotentialNodes,[]string) @protobuf(2,bytes,opt)
}

// PodSchedulingContextStatus describes where resources for the Pod can be allocated.
#PodSchedulingContextStatus: {
	// ResourceClaims describes resource availability for each
	// pod.spec.resourceClaim entry where the corresponding ResourceClaim
	// uses "WaitForFirstConsumer" allocation mode.
	//
	// +listType=map
	// +listMapKey=name
	// +optional
	resourceClaims?: [...#ResourceClaimSchedulingStatus] @go(ResourceClaims,[]ResourceClaimSchedulingStatus) @protobuf(1,bytes,opt)
}

// ResourceClaimSchedulingStatus contains information about one particular
// ResourceClaim with "WaitForFirstConsumer" allocation mode.
#ResourceClaimSchedulingStatus: {
	// Name matches the pod.spec.resourceClaims[*].Name field.
	// +optional
	name?: string @go(Name) @protobuf(1,bytes,opt)

	// UnsuitableNodes lists nodes that the ResourceClaim cannot be
	// allocated for.
	//
	// The size of this field is limited to 128, the same as for
	// PodSchedulingSpec.PotentialNodes. This may get increased in the
	// future, but not reduced.
	//
	// +listType=atomic
	// +optional
	unsuitableNodes?: [...string] @go(UnsuitableNodes,[]string) @protobuf(2,bytes,opt)
}

#PodSchedulingNodeListMaxSize: 128

// PodSchedulingContextList is a collection of Pod scheduling objects.
#PodSchedulingContextList: {
	metav1.#TypeMeta

	// Standard list metadata
	// +optional
	metadata?: metav1.#ListMeta @go(ListMeta) @protobuf(1,bytes,opt)

	// Items is the list of PodSchedulingContext objects.
	items: [...#PodSchedulingContext] @go(Items,[]PodSchedulingContext) @protobuf(2,bytes,rep)
}

// ResourceClass is used by administrators to influence how resources
// are allocated.
//
// This is an alpha type and requires enabling the DynamicResourceAllocation
// feature gate.
#ResourceClass: {
	metav1.#TypeMeta

	// Standard object metadata
	// +optional
	metadata?: metav1.#ObjectMeta @go(ObjectMeta) @protobuf(1,bytes,opt)

	// DriverName defines the name of the dynamic resource driver that is
	// used for allocation of a ResourceClaim that uses this class.
	//
	// Resource drivers have a unique name in forward domain order
	// (acme.example.com).
	driverName: string @go(DriverName) @protobuf(2,bytes)

	// ParametersRef references an arbitrary separate object that may hold
	// parameters that will be used by the driver when allocating a
	// resource that uses this class. A dynamic resource driver can
	// distinguish between parameters stored here and and those stored in
	// ResourceClaimSpec.
	// +optional
	parametersRef?: null | #ResourceClassParametersReference @go(ParametersRef,*ResourceClassParametersReference) @protobuf(3,bytes,opt)

	// Only nodes matching the selector will be considered by the scheduler
	// when trying to find a Node that fits a Pod when that Pod uses
	// a ResourceClaim that has not been allocated yet.
	//
	// Setting this field is optional. If null, all nodes are candidates.
	// +optional
	suitableNodes?: null | v1.#NodeSelector @go(SuitableNodes,*v1.NodeSelector) @protobuf(4,bytes,opt)

	// If and only if allocation of claims using this class is handled
	// via structured parameters, then StructuredParameters must be set to true.
	// +optional
	structuredParameters?: null | bool @go(StructuredParameters,*bool) @protobuf(5,bytes,opt)
}

// ResourceClassList is a collection of classes.
#ResourceClassList: {
	metav1.#TypeMeta

	// Standard list metadata
	// +optional
	metadata?: metav1.#ListMeta @go(ListMeta) @protobuf(1,bytes,opt)

	// Items is the list of resource classes.
	items: [...#ResourceClass] @go(Items,[]ResourceClass) @protobuf(2,bytes,rep)
}

// ResourceClassParametersReference contains enough information to let you
// locate the parameters for a ResourceClass.
#ResourceClassParametersReference: {
	// APIGroup is the group for the resource being referenced. It is
	// empty for the core API. This matches the group in the APIVersion
	// that is used when creating the resources.
	// +optional
	apiGroup?: string @go(APIGroup) @protobuf(1,bytes,opt)

	// Kind is the type of resource being referenced. This is the same
	// value as in the parameter object's metadata.
	kind: string @go(Kind) @protobuf(2,bytes)

	// Name is the name of resource being referenced.
	name: string @go(Name) @protobuf(3,bytes)

	// Namespace that contains the referenced resource. Must be empty
	// for cluster-scoped resources and non-empty for namespaced
	// resources.
	// +optional
	namespace?: string @go(Namespace) @protobuf(4,bytes,opt)
}

// ResourceClaimParametersReference contains enough information to let you
// locate the parameters for a ResourceClaim. The object must be in the same
// namespace as the ResourceClaim.
#ResourceClaimParametersReference: {
	// APIGroup is the group for the resource being referenced. It is
	// empty for the core API. This matches the group in the APIVersion
	// that is used when creating the resources.
	// +optional
	apiGroup?: string @go(APIGroup) @protobuf(1,bytes,opt)

	// Kind is the type of resource being referenced. This is the same
	// value as in the parameter object's metadata, for example "ConfigMap".
	kind: string @go(Kind) @protobuf(2,bytes)

	// Name is the name of resource being referenced.
	name: string @go(Name) @protobuf(3,bytes)
}

// ResourceClaimConsumerReference contains enough information to let you
// locate the consumer of a ResourceClaim. The user must be a resource in the same
// namespace as the ResourceClaim.
#ResourceClaimConsumerReference: {
	// APIGroup is the group for the resource being referenced. It is
	// empty for the core API. This matches the group in the APIVersion
	// that is used when creating the resources.
	// +optional
	apiGroup?: string @go(APIGroup) @protobuf(1,bytes,opt)

	// Resource is the type of resource being referenced, for example "pods".
	resource: string @go(Resource) @protobuf(3,bytes)

	// Name is the name of resource being referenced.
	name: string @go(Name) @protobuf(4,bytes)

	// UID identifies exactly one incarnation of the resource.
	uid: types.#UID @go(UID) @protobuf(5,bytes)
}

// ResourceClaimTemplate is used to produce ResourceClaim objects.
#ResourceClaimTemplate: {
	metav1.#TypeMeta

	// Standard object metadata
	// +optional
	metadata?: metav1.#ObjectMeta @go(ObjectMeta) @protobuf(1,bytes,opt)

	// Describes the ResourceClaim that is to be generated.
	//
	// This field is immutable. A ResourceClaim will get created by the
	// control plane for a Pod when needed and then not get updated
	// anymore.
	spec: #ResourceClaimTemplateSpec @go(Spec) @protobuf(2,bytes)
}

// ResourceClaimTemplateSpec contains the metadata and fields for a ResourceClaim.
#ResourceClaimTemplateSpec: {
	// ObjectMeta may contain labels and annotations that will be copied into the PVC
	// when creating it. No other fields are allowed and will be rejected during
	// validation.
	// +optional
	metadata?: metav1.#ObjectMeta @go(ObjectMeta) @protobuf(1,bytes,opt)

	// Spec for the ResourceClaim. The entire content is copied unchanged
	// into the ResourceClaim that gets created from this template. The
	// same fields as in a ResourceClaim are also valid here.
	spec: #ResourceClaimSpec @go(Spec) @protobuf(2,bytes)
}

// ResourceClaimTemplateList is a collection of claim templates.
#ResourceClaimTemplateList: {
	metav1.#TypeMeta

	// Standard list metadata
	// +optional
	metadata?: metav1.#ListMeta @go(ListMeta) @protobuf(1,bytes,opt)

	// Items is the list of resource claim templates.
	items: [...#ResourceClaimTemplate] @go(Items,[]ResourceClaimTemplate) @protobuf(2,bytes,rep)
}

// ResourceSlice provides information about available
// resources on individual nodes.
#ResourceSlice: {
	metav1.#TypeMeta

	// Standard object metadata
	// +optional
	metadata?: metav1.#ObjectMeta @go(ObjectMeta) @protobuf(1,bytes,opt)

	// NodeName identifies the node which provides the resources
	// if they are local to a node.
	//
	// A field selector can be used to list only ResourceSlice
	// objects with a certain node name.
	//
	// +optional
	nodeName?: string @go(NodeName) @protobuf(2,bytes,opt)

	// DriverName identifies the DRA driver providing the capacity information.
	// A field selector can be used to list only ResourceSlice
	// objects with a certain driver name.
	driverName: string @go(DriverName) @protobuf(3,bytes)

	#ResourceModel
}

// ResourceModel must have one and only one field set.
#ResourceModel: {
	// NamedResources describes available resources using the named resources model.
	//
	// +optional
	namedResources?: null | #NamedResourcesResources @go(NamedResources,*NamedResourcesResources) @protobuf(1,bytes,opt)
}

// ResourceSliceList is a collection of ResourceSlices.
#ResourceSliceList: {
	metav1.#TypeMeta

	// Standard list metadata
	// +optional
	metadata?: metav1.#ListMeta @go(ListMeta) @protobuf(1,bytes,opt)

	// Items is the list of node resource capacity objects.
	items: [...#ResourceSlice] @go(Items,[]ResourceSlice) @protobuf(2,bytes,rep)
}

// ResourceClaimParameters defines resource requests for a ResourceClaim in an
// in-tree format understood by Kubernetes.
#ResourceClaimParameters: {
	metav1.#TypeMeta

	// Standard object metadata
	metadata?: metav1.#ObjectMeta @go(ObjectMeta) @protobuf(1,bytes,opt)

	// If this object was created from some other resource, then this links
	// back to that resource. This field is used to find the in-tree representation
	// of the claim parameters when the parameter reference of the claim refers
	// to some unknown type.
	// +optional
	generatedFrom?: null | #ResourceClaimParametersReference @go(GeneratedFrom,*ResourceClaimParametersReference) @protobuf(2,bytes,opt)

	// Shareable indicates whether the allocated claim is meant to be shareable
	// by multiple consumers at the same time.
	// +optional
	shareable?: bool @go(Shareable) @protobuf(3,bytes,opt)

	// DriverRequests describes all resources that are needed for the
	// allocated claim. A single claim may use resources coming from
	// different drivers. For each driver, this array has at most one
	// entry which then may have one or more per-driver requests.
	//
	// May be empty, in which case the claim can always be allocated.
	//
	// +listType=atomic
	driverRequests?: [...#DriverRequests] @go(DriverRequests,[]DriverRequests) @protobuf(4,bytes,opt)
}

// DriverRequests describes all resources that are needed from one particular driver.
#DriverRequests: {
	// DriverName is the name used by the DRA driver kubelet plugin.
	driverName?: string @go(DriverName) @protobuf(1,bytes,opt)

	// VendorParameters are arbitrary setup parameters for all requests of the
	// claim. They are ignored while allocating the claim.
	//
	// +optional
	vendorParameters?: runtime.#RawExtension @go(VendorParameters) @protobuf(2,bytes,opt)

	// Requests describes all resources that are needed from the driver.
	// +listType=atomic
	requests?: [...#ResourceRequest] @go(Requests,[]ResourceRequest) @protobuf(3,bytes,opt)
}

// ResourceRequest is a request for resources from one particular driver.
#ResourceRequest: {
	// VendorParameters are arbitrary setup parameters for the requested
	// resource. They are ignored while allocating a claim.
	//
	// +optional
	vendorParameters?: runtime.#RawExtension @go(VendorParameters) @protobuf(1,bytes,opt)

	#ResourceRequestModel
}

// ResourceRequestModel must have one and only one field set.
#ResourceRequestModel: {
	// NamedResources describes a request for resources with the named resources model.
	//
	// +optional
	namedResources?: null | #NamedResourcesRequest @go(NamedResources,*NamedResourcesRequest) @protobuf(1,bytes,opt)
}

// ResourceClaimParametersList is a collection of ResourceClaimParameters.
#ResourceClaimParametersList: {
	metav1.#TypeMeta

	// Standard list metadata
	// +optional
	metadata?: metav1.#ListMeta @go(ListMeta) @protobuf(1,bytes,opt)

	// Items is the list of node resource capacity objects.
	items: [...#ResourceClaimParameters] @go(Items,[]ResourceClaimParameters) @protobuf(2,bytes,rep)
}

// ResourceClassParameters defines resource requests for a ResourceClass in an
// in-tree format understood by Kubernetes.
#ResourceClassParameters: {
	metav1.#TypeMeta

	// Standard object metadata
	metadata?: metav1.#ObjectMeta @go(ObjectMeta) @protobuf(1,bytes,opt)

	// If this object was created from some other resource, then this links
	// back to that resource. This field is used to find the in-tree representation
	// of the class parameters when the parameter reference of the class refers
	// to some unknown type.
	// +optional
	generatedFrom?: null | #ResourceClassParametersReference @go(GeneratedFrom,*ResourceClassParametersReference) @protobuf(2,bytes,opt)

	// VendorParameters are arbitrary setup parameters for all claims using
	// this class. They are ignored while allocating the claim. There must
	// not be more than one entry per driver.
	//
	// +listType=atomic
	// +optional
	vendorParameters?: [...#VendorParameters] @go(VendorParameters,[]VendorParameters) @protobuf(3,bytes,opt)

	// Filters describes additional contraints that must be met when using the class.
	//
	// +listType=atomic
	filters?: [...#ResourceFilter] @go(Filters,[]ResourceFilter) @protobuf(4,bytes,opt)
}

// ResourceFilter is a filter for resources from one particular driver.
#ResourceFilter: {
	// DriverName is the name used by the DRA driver kubelet plugin.
	driverName?: string @go(DriverName) @protobuf(1,bytes,opt)

	#ResourceFilterModel
}

// ResourceFilterModel must have one and only one field set.
#ResourceFilterModel: {
	// NamedResources describes a resource filter using the named resources model.
	//
	// +optional
	namedResources?: null | #NamedResourcesFilter @go(NamedResources,*NamedResourcesFilter) @protobuf(1,bytes,opt)
}

// ResourceClassParametersList is a collection of ResourceClassParameters.
#ResourceClassParametersList: {
	metav1.#TypeMeta

	// Standard list metadata
	// +optional
	metadata?: metav1.#ListMeta @go(ListMeta) @protobuf(1,bytes,opt)

	// Items is the list of node resource capacity objects.
	items: [...#ResourceClassParameters] @go(Items,[]ResourceClassParameters) @protobuf(2,bytes,rep)
}

// VendorParameters are opaque parameters for one particular driver.
#VendorParameters: {
	// DriverName is the name used by the DRA driver kubelet plugin.
	driverName?: string @go(DriverName) @protobuf(1,bytes,opt)

	// Parameters can be arbitrary setup parameters. They are ignored while
	// allocating a claim.
	//
	// +optional
	parameters?: runtime.#RawExtension @go(Parameters) @protobuf(2,bytes,opt)
}
